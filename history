{
                            list<int> *rec = GetMatchList(SEC_LIST, i);
                            if (rec != nullptr) {
                                printf("\n------");
                            }
                        }

                        switch (i){
                                            case 0:
                                                //not find ,continue to search next director
                                            {
                                                list<int> *rec = GetMatchList(SEC_LIST, i);
                                                if (rec != nullptr) {
                                                    printf("\n------");
                                                }
                                            }
                                                break;
                                            case 1:
                                                //donot jummp,continue to search next director
                                            {
                                                list<int> *rec = GetMatchList(SEC_LIST, i);
                                                if (rec != nullptr) {
                                                    printf("\n------");
                                                }
                                            }
                                                break;
                                            case 2:
                                                if(SEC_LIST[0] != SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN){
                                                    //if one step is chess ,the second step is dump , find a path
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);;
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr ){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }
                                                else if(SEC_LIST[0] == SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN){
                                                    //if one step is dump, the second step is dump too, the chess can move one step ,find a path
                                                    set<int>::iterator it_temp0 = sec_visited.find(0);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }

                                                } else if(SEC_LIST[0] == SHARELIGHTGREEN && SEC_LIST[1] != SHARELIGHTGREEN){
                                                    // if one step is dump ,the second step is chess, the chess can monve one step too, find a path;
                                                    set<int>::iterator it_temp0 = sec_visited.find(0);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else {
                                                    //if one step is chess, the second step is chess to, donot move ,continue to search next director
                                                }
                                                {
                                                    list<int> *rec = GetMatchList(SEC_LIST, i);
                                                    if (rec != nullptr) {
                                                        printf("\n------");
                                                    }
                                                }
                                                break;
                                            case 3:
                                                if((SEC_LIST[0] ==SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN && SEC_LIST[2] == SHARELIGHTGREEN) ||
                                                    (SEC_LIST[0] == SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN && SEC_LIST[2] != SHARELIGHTGREEN) ||
                                                    (SEC_LIST[0] == SHARELIGHTGREEN && SEC_LIST[1] != SHARELIGHTGREEN && SEC_LIST[2] !=SHARELIGHTGREEN)){
                                                    set<int>::iterator it_temp0 = sec_visited.find(0);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }

                                                } else if(SEC_LIST[0] == SHARELIGHTGREEN && SEC_LIST[1] != SHARELIGHTGREEN && SEC_LIST[2] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(2);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }

                                                } else if((SEC_LIST[0] != SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN && SEC_LIST[2] == SHARELIGHTGREEN) ||
                                                        (SEC_LIST[0] != SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN && SEC_LIST[2] != SHARELIGHTGREEN)){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN && SEC_LIST[1] != SHARELIGHTGREEN) {
                                                    //no way
                                                }
                                                break;
                                            case 4:
                                                if(SEC_LIST[0]==SHARELIGHTGREEN && SEC_LIST[1] != SHARELIGHTGREEN && SEC_LIST[2] == SHARELIGHTGREEN &&SEC_LIST[3] ==SHARELIGHTGREEN ){
                                                    set<int>::iterator it_temp0 = sec_visited.find(3);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(0);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }

                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN && SEC_LIST[2] !=SHARELIGHTGREEN && SEC_LIST[3] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(3);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else {
                                                    //no way
                                                }
                                                {
                                                    list<int> *rec = GetMatchList(SEC_LIST, i);
                                                    if (rec != nullptr) {
                                                        printf("\n------");
                                                    }
                                                }
                                                break;
                                            case 5:
                                                if(SEC_LIST[0] == SHARELIGHTGREEN && SEC_LIST[1] != SHARELIGHTGREEN && SEC_LIST[2] == SHARELIGHTGREEN && SEC_LIST[3] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(3);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(0);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN && SEC_LIST[2] != SHARELIGHTGREEN && SEC_LIST[3] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(3);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else{
                                                    //no way
                                                }
                                                {
                                                    list<int> *rec = GetMatchList(SEC_LIST, i);
                                                    if (rec != nullptr) {
                                                        printf("\n------");
                                                    }
                                                }
                                                break;
                                            case 6:
                                                if(SEC_LIST[0] == SHARELIGHTGREEN && SEC_LIST[1] !=SHARELIGHTGREEN && SEC_LIST[2] == SHARELIGHTGREEN && SEC_LIST[3] == SHARELIGHTGREEN && SEC_LIST[4] != SHARELIGHTGREEN && SEC_LIST[5]==SHARELIGHTGREEN){
                                                // 0 1 0 0 1 0
                                                    set<int>::iterator it_temp0 = sec_visited.find(3);
                                                    set<int>::iterator it_temp1 = sec_visited.find(5);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else if (SEC_LIST[0] == SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN && SEC_LIST[2] != SHARELIGHTGREEN && SEC_LIST[3]==SHARELIGHTGREEN && SEC_LIST[4] == SHARELIGHTGREEN && SEC_LIST[5] == SHARELIGHTGREEN){
                                                //0 0 1 0 0 0
                                                    set<int>::iterator it_temp0 = sec_visited.find(5);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else if(SEC_LIST[0] == SHARELIGHTGREEN && SEC_LIST[1] != SHARELIGHTGREEN && SEC_LIST[2] == SHARELIGHTGREEN && SEC_LIST[3] == SHARELIGHTGREEN){
                                                // 0 1 0 0
                                                    set<int>::iterator it_temp0 = sec_visited.find(3);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(0);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN && SEC_LIST[1]==SHARELIGHTGREEN && SEC_LIST[2] != SHARELIGHTGREEN && SEC_LIST[3] == SHARELIGHTGREEN && SEC_LIST[4] != SHARELIGHTGREEN && SEC_LIST[5] == SHARELIGHTGREEN){
                                                    // 1 0 1 0 1 0
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(3);
                                                    set<int>::iterator it_temp2 = sec_visited.find(5);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    CircleReturn *p2 = GetNodeInfo(*it_temp2);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        listnode->push_back(*p2);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }

                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN && SEC_LIST[2] == SHARELIGHTGREEN && SEC_LIST[3] != SHARELIGHTGREEN && SEC_LIST[4] == SHARELIGHTGREEN && SEC_LIST[5] == SHARELIGHTGREEN ){
                                                    // 1 0 0 1  0 0
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(5);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN && SEC_LIST[1] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else{
                                                    //no way
                                                }
                                                {
                                                    list<int> *rec = GetMatchList(SEC_LIST, i);
                                                    if (rec != nullptr) {
                                                        printf("\n------");
                                                    }
                                                }
                                                break;
                                            case 7:
                                                if(SEC_LIST[0] == SHARELIGHTGREEN &&
                                                   SEC_LIST[1] != SHARELIGHTGREEN &&
                                                   SEC_LIST[2] == SHARELIGHTGREEN &&
                                                   SEC_LIST[3] == SHARELIGHTGREEN &&
                                                   SEC_LIST[4] != SHARELIGHTGREEN &&
                                                   SEC_LIST[5] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(3);
                                                    set<int>::iterator it_temp1 = sec_visited.find(5);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] == SHARELIGHTGREEN &&
                                                          SEC_LIST[1] != SHARELIGHTGREEN &&
                                                          SEC_LIST[2] == SHARELIGHTGREEN &&
                                                          SEC_LIST[3] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(3);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }

                                                } else if(SEC_LIST[0] == SHARELIGHTGREEN &&
                                                          SEC_LIST[1] == SHARELIGHTGREEN &&
                                                          SEC_LIST[2] != SHARELIGHTGREEN &&
                                                          SEC_LIST[3] == SHARELIGHTGREEN &&
                                                          SEC_LIST[4] == SHARELIGHTGREEN &&
                                                          SEC_LIST[5] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(5);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }

                                                } else if(SEC_LIST[0] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(0);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }

                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                          SEC_LIST[1] == SHARELIGHTGREEN &&
                                                          SEC_LIST[2] != SHARELIGHTGREEN &&
                                                          SEC_LIST[3] == SHARELIGHTGREEN &&
                                                          SEC_LIST[4] != SHARELIGHTGREEN &&
                                                          SEC_LIST[5] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(3);
                                                    set<int>::iterator it_temp2 = sec_visited.find(5);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    CircleReturn *p2 = GetNodeInfo(*it_temp2);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        listnode->push_back(*p2);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }

                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                          SEC_LIST[1] == SHARELIGHTGREEN &&
                                                          SEC_LIST[2] == SHARELIGHTGREEN &&
                                                          SEC_LIST[3] != SHARELIGHTGREEN &&
                                                          SEC_LIST[4] == SHARELIGHTGREEN &&
                                                          SEC_LIST[5] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(5);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                          SEC_LIST[1] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }

                                                } else{
                                                    //no way
                                                }
                                                {
                                                    list<int> *rec = GetMatchList(SEC_LIST, i);
                                                    if (rec != nullptr) {
                                                        printf("\n------");
                                                    }
                                                }
                                                break;
                                            case 8:
                                                if(SEC_LIST[0] == SHARELIGHTGREEN &&
                                                   SEC_LIST[1] != SHARELIGHTGREEN &&
                                                   SEC_LIST[2] == SHARELIGHTGREEN &&
                                                   SEC_LIST[3] == SHARELIGHTGREEN &&
                                                   SEC_LIST[4] != SHARELIGHTGREEN &&
                                                   SEC_LIST[5] == SHARELIGHTGREEN &&
                                                   SEC_LIST[6] != SHARELIGHTGREEN &&
                                                   SEC_LIST[7] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(3);
                                                    set<int>::iterator it_temp1 = sec_visited.find(5);
                                                    set<int>::iterator it_temp2 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    CircleReturn *p2 = GetNodeInfo(*it_temp2);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        listnode->push_back(*p2);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if (SEC_LIST[0] == SHARELIGHTGREEN &&
                                                           SEC_LIST[1] != SHARELIGHTGREEN &&
                                                           SEC_LIST[2] == SHARELIGHTGREEN &&
                                                           SEC_LIST[3] == SHARELIGHTGREEN &&
                                                           SEC_LIST[4] != SHARELIGHTGREEN &&
                                                           SEC_LIST[5] == SHARELIGHTGREEN
                                                           ){
                                                    set<int>::iterator it_temp0 = sec_visited.find(3);
                                                    set<int>::iterator it_temp1 = sec_visited.find(5);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] == SHARELIGHTGREEN &&
                                                          SEC_LIST[1] != SHARELIGHTGREEN &&
                                                          SEC_LIST[2] == SHARELIGHTGREEN &&
                                                          SEC_LIST[3] == SHARELIGHTGREEN
                                                          ){
                                                    set<int>::iterator it_temp0 = sec_visited.find(3);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] == SHARELIGHTGREEN &&
                                                          SEC_LIST[1] == SHARELIGHTGREEN &&
                                                          SEC_LIST[2] != SHARELIGHTGREEN &&
                                                          SEC_LIST[3] == SHARELIGHTGREEN &&
                                                          SEC_LIST[4] == SHARELIGHTGREEN &&
                                                          SEC_LIST[5] == SHARELIGHTGREEN &&
                                                          SEC_LIST[6] != SHARELIGHTGREEN &&
                                                          SEC_LIST[7] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(5);
                                                    set<int>::iterator it_temp1 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else if(SEC_LIST[0] == SHARELIGHTGREEN ){
                                                    set<int>::iterator it_temp0 = sec_visited.find(0);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                          SEC_LIST[1] == SHARELIGHTGREEN &&
                                                          SEC_LIST[2] != SHARELIGHTGREEN &&
                                                          SEC_LIST[3] == SHARELIGHTGREEN &&
                                                          SEC_LIST[4] != SHARELIGHTGREEN &&
                                                          SEC_LIST[5] == SHARELIGHTGREEN &&
                                                          SEC_LIST[6] != SHARELIGHTGREEN &&
                                                          SEC_LIST[7] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(3);
                                                    set<int>::iterator it_temp2 = sec_visited.find(5);
                                                    set<int>::iterator it_temp3 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    CircleReturn *p2 = GetNodeInfo(*it_temp2);
                                                    CircleReturn *p3 = GetNodeInfo(*it_temp2);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        listnode->push_back(*p2);
                                                        listnode->push_back(*p3);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                          SEC_LIST[1] == SHARELIGHTGREEN &&
                                                          SEC_LIST[2] != SHARELIGHTGREEN &&
                                                          SEC_LIST[3] == SHARELIGHTGREEN &&
                                                          SEC_LIST[4] != SHARELIGHTGREEN &&
                                                          SEC_LIST[5] == SHARELIGHTGREEN
                                                          ){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(3);
                                                    set<int>::iterator it_temp2 = sec_visited.find(5);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    CircleReturn *p2 = GetNodeInfo(*it_temp2);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        listnode->push_back(*p2);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                         SEC_LIST[1] == SHARELIGHTGREEN &&
                                                         SEC_LIST[2] != SHARELIGHTGREEN &&
                                                         SEC_LIST[3] == SHARELIGHTGREEN
                                                        ){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(3);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                          SEC_LIST[1] == SHARELIGHTGREEN &&
                                                          SEC_LIST[2] == SHARELIGHTGREEN &&
                                                          SEC_LIST[3] != SHARELIGHTGREEN &&
                                                          SEC_LIST[4] == SHARELIGHTGREEN &&
                                                          SEC_LIST[5] == SHARELIGHTGREEN &&
                                                          SEC_LIST[6] != SHARELIGHTGREEN &&
                                                          SEC_LIST[7] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(5);
                                                    set<int>::iterator it_temp2 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    CircleReturn *p2 = GetNodeInfo(*it_temp2);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        listnode->push_back(*p2);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                         SEC_LIST[1] == SHARELIGHTGREEN &&
                                                         SEC_LIST[2] == SHARELIGHTGREEN &&
                                                         SEC_LIST[3] != SHARELIGHTGREEN &&
                                                         SEC_LIST[4] == SHARELIGHTGREEN &&
                                                         SEC_LIST[5] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(5);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                         SEC_LIST[1] == SHARELIGHTGREEN &&
                                                         SEC_LIST[2] == SHARELIGHTGREEN &&
                                                         SEC_LIST[3] == SHARELIGHTGREEN &&
                                                         SEC_LIST[4] != SHARELIGHTGREEN &&
                                                         SEC_LIST[5] == SHARELIGHTGREEN &&
                                                         SEC_LIST[6] == SHARELIGHTGREEN &&
                                                         SEC_LIST[7] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                         SEC_LIST[1] == SHARELIGHTGREEN
                                                        ){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }
                                                {
                                                    list<int> *rec = GetMatchList(SEC_LIST, i);
                                                    if (rec != nullptr) {
                                                        printf("\n------");
                                                    }
                                                }
                                                break;
                                            case 9:
                                                if(SEC_LIST[0] == SHARELIGHTGREEN &&
                                                   SEC_LIST[1] != SHARELIGHTGREEN &&
                                                   SEC_LIST[2] == SHARELIGHTGREEN &&
                                                   SEC_LIST[3] == SHARELIGHTGREEN &&
                                                   SEC_LIST[4] != SHARELIGHTGREEN &&
                                                   SEC_LIST[5] == SHARELIGHTGREEN &&
                                                   SEC_LIST[6] != SHARELIGHTGREEN &&
                                                   SEC_LIST[7] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(3);
                                                    set<int>::iterator it_temp1 = sec_visited.find(5);
                                                    set<int>::iterator it_temp2 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    CircleReturn *p2 = GetNodeInfo(*it_temp2);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        listnode->push_back(*p2);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if (SEC_LIST[0] == SHARELIGHTGREEN &&
                                                           SEC_LIST[1] != SHARELIGHTGREEN &&
                                                           SEC_LIST[2] == SHARELIGHTGREEN &&
                                                           SEC_LIST[3] == SHARELIGHTGREEN &&
                                                           SEC_LIST[4] == SHARELIGHTGREEN &&
                                                           SEC_LIST[5] != SHARELIGHTGREEN &&
                                                           SEC_LIST[6] == SHARELIGHTGREEN &&
                                                           SEC_LIST[7] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(3);
                                                    set<int>::iterator it_temp1 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if (SEC_LIST[0] == SHARELIGHTGREEN &&
                                                          SEC_LIST[1]  == SHARELIGHTGREEN &&
                                                          SEC_LIST[2]  != SHARELIGHTGREEN &&
                                                          SEC_LIST[3]  == SHARELIGHTGREEN &&
                                                          SEC_LIST[4]  == SHARELIGHTGREEN &&
                                                          SEC_LIST[5]  == SHARELIGHTGREEN &&
                                                          SEC_LIST[6]  != SHARELIGHTGREEN &&
                                                          SEC_LIST[7]  == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(5);
                                                    set<int>::iterator it_temp1 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else if (SEC_LIST[0] == SHARELIGHTGREEN &&
                                                          SEC_LIST[1] == SHARELIGHTGREEN &&
                                                          SEC_LIST[2] == SHARELIGHTGREEN &&
                                                          SEC_LIST[3] != SHARELIGHTGREEN &&
                                                          SEC_LIST[4] == SHARELIGHTGREEN &&
                                                          SEC_LIST[5] == SHARELIGHTGREEN &&
                                                          SEC_LIST[6] == SHARELIGHTGREEN &&
                                                          SEC_LIST[7] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(0);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                          SEC_LIST[1] == SHARELIGHTGREEN &&
                                                          SEC_LIST[2] != SHARELIGHTGREEN &&
                                                          SEC_LIST[3] == SHARELIGHTGREEN &&
                                                          SEC_LIST[4] != SHARELIGHTGREEN &&
                                                          SEC_LIST[5] == SHARELIGHTGREEN &&
                                                          SEC_LIST[6] != SHARELIGHTGREEN &&
                                                          SEC_LIST[7] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(3);
                                                    set<int>::iterator it_temp2 = sec_visited.find(5);
                                                    set<int>::iterator it_temp3 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    CircleReturn *p2 = GetNodeInfo(*it_temp2);
                                                    CircleReturn *p3 = GetNodeInfo(*it_temp2);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        listnode->push_back(*p2);
                                                        listnode->push_back(*p3);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                         SEC_LIST[1] == SHARELIGHTGREEN &&
                                                         SEC_LIST[2] == SHARELIGHTGREEN &&
                                                         SEC_LIST[3] != SHARELIGHTGREEN &&
                                                         SEC_LIST[4] == SHARELIGHTGREEN &&
                                                         SEC_LIST[5] == SHARELIGHTGREEN &&
                                                         SEC_LIST[6] != SHARELIGHTGREEN &&
                                                         SEC_LIST[7] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(5);
                                                    set<int>::iterator it_temp2 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    CircleReturn *p2 = GetNodeInfo(*it_temp2);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        listnode->push_back(*p2);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }else if(SEC_LIST[0] != SHARELIGHTGREEN &&
                                                         SEC_LIST[1] == SHARELIGHTGREEN &&
                                                         SEC_LIST[2] == SHARELIGHTGREEN &&
                                                         SEC_LIST[3] == SHARELIGHTGREEN &&
                                                         SEC_LIST[4] != SHARELIGHTGREEN &&
                                                         SEC_LIST[5] == SHARELIGHTGREEN &&
                                                         SEC_LIST[6] == SHARELIGHTGREEN &&
                                                         SEC_LIST[7] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    set<int>::iterator it_temp1 = sec_visited.find(7);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    CircleReturn *p1 = GetNodeInfo(*it_temp1);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        listnode->push_back(*p1);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                } else if (SEC_LIST[0] != SHARELIGHTGREEN &&
                                                           SEC_LIST[1] == SHARELIGHTGREEN){
                                                    set<int>::iterator it_temp0 = sec_visited.find(1);
                                                    CircleReturn *p0 = GetNodeInfo(*it_temp0);
                                                    if(p0 != nullptr){
                                                        list<CircleReturn> *listnode = new list<CircleReturn>();
                                                        listnode->push_back(*p0);
                                                        stringid_make << cur_type << "|";
                                                        result_map->insert(pair<string,list<CircleReturn>>(stringid_make.str(),*listnode));
                                                    }
                                                }
                                                {
                                                    list<int> *rec = GetMatchList(SEC_LIST, i);
                                                    if (rec != nullptr) {
                                                        printf("\n------");
                                                    }
                                                }
                                                break;
                                            case 10:
                                            {
                                                list<int> *rec = GetMatchList(SEC_LIST, i);
                                                if (rec != nullptr) {
                                                    printf("\n------");
                                                }
                                            }
                                                break;
                                            case 11:
                                            {
                                                list<int> *rec = GetMatchList(SEC_LIST, i);
                                                if (rec != nullptr) {
                                                    printf("\n------");
                                                }
                                            }
                                                break;
                                            case 12:
                                            {
                                                list<int> *rec = GetMatchList(SEC_LIST, i);
                                                if (rec != nullptr) {
                                                    printf("\n------");
                                                }
                                            }
                                                break;
                                            case 13: {
                                                    list<int> *rec = GetMatchList(SEC_LIST, i);
                                                    if (rec != nullptr) {
                                                        printf("\n------");
                                                    }
                                                }
                                                break;
                                            default:
                                                break;
                                        }//switch